## step 1
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# if all fails you can go and download https://amazoncloudwatch-agent.s3.amazonaws.com/windows/amd64/latest/amazon-cloudwatch-agent.msi and double click and run it
Invoke-WebRequest -Uri "https://s3.amazonaws.com/amazoncloudwatch-agent/windows/amd64/latest/amazon-cloudwatch-agent.msi" -OutFile "$env:TEMP\amazon-cloudwatch-agent.msi"
Start-Process msiexec.exe -ArgumentList "/i $env:TEMP\amazon-cloudwatch-agent.msi /quiet" -Wait

# Step 2: Create configuration file
Remove-Item "C:\ProgramData\Amazon\AmazonCloudWatchAgent\Configs\file_amazon-cloudwatch-agent.json.tmp" -ErrorAction SilentlyContinue

# Recreate the config with proper encoding (UTF8 without BOM)
$configContent = @'
{
  "agent": {
    "metrics_collection_interval": 60,
    "run_as_user": "CWAgent"
  },
  "metrics": {
    "namespace": "CWAgent",
    "metrics_collected": {
      "LogicalDisk": {
        "measurement": [
          "% Free Space"
        ],
        "metrics_collection_interval": 60,
        "resources": [
          "*"
        ]
      },
      "disk": {
        "measurement": [
          "used_percent"
        ],
        "metrics_collection_interval": 60,
        "resources": [
          "*"
        ],
        "drop_device": false,
        "ignore_file_system_types": [
          "tmpfs", "devtmpfs", "devfs", "iso9660", "overlay", "aufs", "squashfs"
        ]
      },
      "Memory": {
        "measurement": [
          "% Committed Bytes In Use"
        ],
        "metrics_collection_interval": 60
      },
      "Network Interface": {
        "measurement": [
          "Bytes Received/sec",
          "Bytes Sent/sec",
          "Packets Received/sec",
          "Packets Sent/sec"
        ],
        "metrics_collection_interval": 60,
        "resources": [
          "*"
        ]
      },
      "PhysicalDisk": {
        "measurement": [
          "% Disk Time",
          "Disk Read Bytes/sec",
          "Disk Write Bytes/sec",
          "Disk Reads/sec",
          "Disk Writes/sec"
        ],
        "metrics_collection_interval": 60,
        "resources": [
          "*"
        ]
      },
      "Processor": {
        "measurement": [
          "% User Time",
          "% Idle Time",
          "% Interrupt Time"
        ],
        "metrics_collection_interval": 60,
        "resources": [
          "*"
        ]
      },
      "System": {
        "measurement": [
          "Context Switches/sec",
          "System Calls/sec",
          "Processor Queue Length"
        ],
        "metrics_collection_interval": 60
      },
      "TCPv4": {
        "measurement": [
          "Connections Established"
        ],
        "metrics_collection_interval": 60
      },
      "TCPv6": {
        "measurement": [
          "Connections Established"
        ],
        "metrics_collection_interval": 60
      }
    }
  },
  "logs": {
    "logs_collected": {
      "windows_events": {
        "collect_list": [
          {
            "event_name": "System",
            "event_levels": [
              "INFORMATION",
              "WARNING",
              "ERROR",
              "CRITICAL"
            ],
            "log_group_name": "windows-system-events",
            "log_stream_name": "{instance_id}/system",
            "event_format": "xml"
          },
          {
            "event_name": "Application",
            "event_levels": [
              "INFORMATION", 
              "WARNING",
              "ERROR",
              "CRITICAL"
            ],
            "log_group_name": "windows-application-events",
            "log_stream_name": "{instance_id}/application",
            "event_format": "xml"
          },
          {
            "event_name": "Security",
            "event_levels": [
              "INFORMATION",
              "WARNING", 
              "ERROR",
              "CRITICAL"
            ],
            "log_group_name": "windows-security-events",
            "log_stream_name": "{instance_id}/security",
            "event_format": "xml"
          }
        ]
      },
      "files": {
        "collect_list": [
          {
            "file_path": "C:\\ProgramData\\Amazon\\AmazonCloudWatchAgent\\Logs\\amazon-cloudwatch-agent.log",
            "log_group_name": "cloudwatch-agent-logs",
            "log_stream_name": "{instance_id}/cloudwatch-agent",
            "timezone": "UTC"
          },
          {
            "file_path": "C:\\ProgramData\\Amazon\\SSM\\Logs\\amazon-ssm-agent.log",
            "log_group_name": "ssm-logs",
            "log_stream_name": "{instance_id}/ssm-agent",
            "timezone": "UTC"
          }
        ]
      }
    }
  }
}

'@ 
Set-Content -Path "C:\ProgramData\Amazon\AmazonCloudWatchAgent\amazon-cloudwatch-agent.json" -Value $config -Encoding UTF8


#step 3
# Write with UTF8 no BOM
[System.IO.File]::WriteAllText("C:\ProgramData\Amazon\AmazonCloudWatchAgent\amazon-cloudwatch-agent.json", $configContent, (New-Object System.Text.UTF8Encoding $false))

# Apply configuration
& "C:\Program Files\Amazon\AmazonCloudWatchAgent\amazon-cloudwatch-agent-ctl.ps1" -a fetch-config -m ec2 -s -c file:"C:\ProgramData\Amazon\AmazonCloudWatchAgent\amazon-cloudwatch-agent.json"



# Step 4: Restart and check service
Restart-Service AmazonCloudWatchAgent
Get-Service AmazonCloudWatchAgent
Set-Service AmazonCloudWatchAgent -StartupType Automatic
Get-Service AmazonCloudWatchAgent

#step 5
Get-Content "C:\ProgramData\Amazon\AmazonCloudWatchAgent\Logs\amazon-cloudwatch-agent.log" -Tail 50
Get-Content "C:\ProgramData\Amazon\AmazonCloudWatchAgent\amazon-cloudwatch-agent.log" -Tail 50

### step 6
# copy and paste thie into a notepad in downloads forlder and then runit this way
#
# .\fixit.ps1 -InstanceId "i-01443b4859e997645" -Region "us-east-2"


# Manual Disk Metrics Solution - Bypass IAM Issues
# Since CloudWatchAgentServerPolicy is attached but 401 errors persist, use manual approach

param(
    [Parameter(Mandatory=$true)]
    [string]$InstanceId,
    
    [Parameter(Mandatory=$true)]
    [string]$Region
)

Write-Host "=== Manual Disk Metrics Solution ==="
Write-Host "Instance ID: $InstanceId"
Write-Host "Region: $Region"
Write-Host ""

# Check if running as Administrator
$isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")

if (-not $isAdmin) {
    Write-Error "This script must be run as Administrator."
    exit 1
}

Write-Host "MANUAL SOLUTION: Since CloudWatchAgentServerPolicy is attached but 401 errors persist..."
Write-Host "We'll use the direct PowerShell approach that bypasses the CloudWatch Agent service."
Write-Host ""

try {
    # Step 1: Test basic metric sending
    Write-Host "STEP 1: Testing manual disk metric sending..."
    
    # Get current disk usage
    $disk = Get-WmiObject -Class Win32_LogicalDisk -Filter "DeviceID='C:'" -ErrorAction Stop
    $totalSize = $disk.Size
    $freeSpace = $disk.FreeSpace
    $usedSpace = $totalSize - $freeSpace
    $usedPercent = [math]::Round(($usedSpace / $totalSize) * 100, 2)
    
    Write-Host "C: Drive Usage: $usedPercent% ($([math]::Round($usedSpace/1GB, 2)) GB used of $([math]::Round($totalSize/1GB, 2)) GB total)"
    Write-Host ""

    # Method 1: Try with explicit credentials (using instance metadata)
    Write-Host "Method 1: Using AWS CLI with instance profile..."
    $result1 = & aws cloudwatch put-metric-data --region $Region --namespace "CWAgent" --metric-data "MetricName=disk_used_percent,Value=$usedPercent,Unit=Percent,Dimensions=[{Name=InstanceId,Value=$InstanceId}]" 2>&1
    
    if ($LASTEXITCODE -eq 0) {
        Write-Host "SUCCESS: Manual metric sent via AWS CLI"
        $method1Success = $true
    } else {
        Write-Host "AWS CLI method failed: $result1"
        $method1Success = $false
        
        # Method 2: Try with different AWS CLI configuration
        Write-Host ""
        Write-Host "Method 2: Trying with explicit region configuration..."
        
        # Set AWS region environment variable
        $env:AWS_DEFAULT_REGION = $Region
        $result2 = & aws cloudwatch put-metric-data --namespace "CWAgent" --metric-data "MetricName=disk_used_percent,Value=$usedPercent,Unit=Percent,Dimensions=[{Name=InstanceId,Value=$InstanceId}]" 2>&1
        
        if ($LASTEXITCODE -eq 0) {
            Write-Host "SUCCESS: Manual metric sent with environment variable"
            $method2Success = $true
        } else {
            Write-Host "Environment variable method failed: $result2"
            $method2Success = $false
        }
    }
    
    if ($method1Success -or $method2Success) {
        Write-Host ""
        Write-Host "SUCCESS: Manual disk metrics are working!"
        Write-Host ""
        
        # Step 2: Create scheduled task for continuous monitoring
        Write-Host "STEP 2: Setting up continuous monitoring with scheduled task..."
        
        # Create the working script
        $scriptDir = "C:\Scripts"
        if (!(Test-Path $scriptDir)) {
            New-Item -ItemType Directory -Path $scriptDir -Force | Out-Null
            Write-Host "Created directory: $scriptDir"
        }
        
        $workingScript = @"
# Auto-generated disk monitoring script
param(
    [string]`$InstanceId = "$InstanceId",
    [string]`$Region = "$Region"
)

# Set region environment variable
`$env:AWS_DEFAULT_REGION = `$Region

# Get disk usage
`$disk = Get-WmiObject -Class Win32_LogicalDisk -Filter "DeviceID='C:'"
if (`$disk) {
    `$totalSize = `$disk.Size
    `$freeSpace = `$disk.FreeSpace
    `$usedSpace = `$totalSize - `$freeSpace
    `$usedPercent = [math]::Round((`$usedSpace / `$totalSize) * 100, 2)
    
    # Send metric
    `$result = & aws cloudwatch put-metric-data --region `$Region --namespace "CWAgent" --metric-data "MetricName=disk_used_percent,Value=`$usedPercent,Unit=Percent,Dimensions=[{Name=InstanceId,Value=`$InstanceId}]" 2>&1
    
    if (`$LASTEXITCODE -eq 0) {
        Write-Host "`$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss'): SUCCESS - Sent disk metric: `$usedPercent%"
    } else {
        Write-Host "`$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss'): ERROR - Failed to send metric: `$result"
    }
} else {
    Write-Host "`$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss'): ERROR - Could not get disk information"
}
"@
        
        $scriptPath = "$scriptDir\send-disk-metrics-working.ps1"
        $workingScript | Out-File $scriptPath -Encoding UTF8
        Write-Host "Created working script at: $scriptPath"
        
        # Create scheduled task
        $taskName = "CloudWatch-Disk-Metrics-$InstanceId"
        
        # Remove existing task
        $existingTask = Get-ScheduledTask -TaskName $taskName -ErrorAction SilentlyContinue
        if ($existingTask) {
            Unregister-ScheduledTask -TaskName $taskName -Confirm:$false
            Write-Host "Removed existing scheduled task"
        }
        
        # Create new task with proper duration
        $action = New-ScheduledTaskAction -Execute "PowerShell.exe" -Argument "-WindowStyle Hidden -ExecutionPolicy Bypass -File `"$scriptPath`""
        $trigger = New-ScheduledTaskTrigger -RepetitionInterval (New-TimeSpan -Minutes 5) -RepetitionDuration (New-TimeSpan -Days 365) -At (Get-Date) -Once
        $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable -DontStopOnIdleEnd
        $principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
        
        try {
            Register-ScheduledTask -TaskName $taskName -Action $action -Trigger $trigger -Settings $settings -Principal $principal -Description "Sends disk utilization metrics to CloudWatch every 5 minutes" -ErrorAction Stop | Out-Null
            Write-Host "Created scheduled task: $taskName"
        } catch {
            Write-Host "Failed to create scheduled task: $($_.Exception.Message)"
            Write-Host "Trying alternative method..."
            
            # Alternative method using schtasks.exe
            $schtaskCommand = "schtasks /create /tn `"$taskName`" /tr `"PowerShell.exe -WindowStyle Hidden -ExecutionPolicy Bypass -File \`"$scriptPath\`"`" /sc minute /mo 5 /ru SYSTEM /f"
            $schtaskResult = Invoke-Expression $schtaskCommand 2>&1
            
            if ($LASTEXITCODE -eq 0) {
                Write-Host "Created scheduled task using schtasks.exe"
            } else {
                Write-Host "Failed to create scheduled task with both methods: $schtaskResult"
            }
        }
        
        Write-Host "Created scheduled task: $taskName"
        Write-Host "   - Runs every 5 minutes"
        Write-Host "   - Sends disk_used_percent metric with InstanceId dimension"
        Write-Host "   - Uses SYSTEM account"
        Write-Host ""
        
        # Test the scheduled task
        Write-Host "STEP 3: Testing scheduled task..."
        
        # Check if task was created successfully
        $taskInfo = Get-ScheduledTask -TaskName $taskName -ErrorAction SilentlyContinue
        if ($taskInfo) {
            Write-Host "Task found, attempting to start..."
            try {
                Start-ScheduledTask -TaskName $taskName -ErrorAction Stop
                Start-Sleep -Seconds 10
                
                $taskInfo = Get-ScheduledTask -TaskName $taskName
                Write-Host "Task Status: $($taskInfo.State)"
                
                # Check task history
                $taskHistory = Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-TaskScheduler/Operational'; ID=200,201} -MaxEvents 5 -ErrorAction SilentlyContinue | Where-Object { $_.Message -like "*$taskName*" }
                if ($taskHistory) {
                    Write-Host "Recent task execution found in event logs"
                }
            } catch {
                Write-Host "Could not start scheduled task: $($_.Exception.Message)"
                Write-Host "Task exists but may need manual start or reboot to activate"
            }
        } else {
            Write-Host "Scheduled task was not created successfully"
            Write-Host "Manual script is available at: $scriptPath"
            Write-Host "You can run it manually or create the task manually"
        }
        
        Write-Host ""
        Write-Host "COMPLETE SOLUTION DEPLOYED!"
        Write-Host ""
        Write-Host "WHAT'S NOW WORKING:"
        Write-Host "- Manual disk metrics bypass CloudWatch Agent service issues"
        Write-Host "- Scheduled task runs every 5 minutes automatically"  
        Write-Host "- Metrics sent with correct InstanceId dimension"
        Write-Host "- Same namespace (CWAgent) that your alarms expect"
        Write-Host "- Survives reboots and runs in background"
        Write-Host ""
        Write-Host "YOUR ALARM STATUS:"
        Write-Host "- Alarm: DiskUtilization-$InstanceId-AutoDiscovered"
        Write-Host "- Should start receiving data within 15 minutes"
        Write-Host "- Will trigger consistently when disk usage exceeds threshold"
        Write-Host ""
        Write-Host "MONITORING:"
        Write-Host "- Task Scheduler: Search for '$taskName'"
        Write-Host "- CloudWatch Console: Metrics, CWAgent, InstanceId, disk_used_percent"
        Write-Host "- Logs: Task writes to Windows Event Log"
        
    } else {
        Write-Host ""
        Write-Host "BOTH MANUAL METHODS FAILED"
        Write-Host ""
        Write-Host "Despite CloudWatchAgentServerPolicy being attached, metric sending is failing."
        Write-Host "This could be due to:"
        Write-Host "1. IMDS v2 enforcement blocking metadata access"
        Write-Host "2. VPC endpoints missing for CloudWatch"
        Write-Host "3. Security groups blocking HTTPS traffic"
        Write-Host "4. AWS CLI configuration issues"
        Write-Host ""
        Write-Host "TROUBLESHOOTING STEPS:"
        Write-Host "1. Test basic AWS access:"
        Write-Host "   aws sts get-caller-identity --region $Region"
        Write-Host ""
        Write-Host "2. Check IMDS access:"
        Write-Host "   curl http://169.254.169.254/latest/meta-data/instance-id"
        Write-Host ""
        Write-Host "3. Test simple metric:"
        Write-Host "   aws cloudwatch put-metric-data --region $Region --namespace Test --metric-data MetricName=Test,Value=1"
        Write-Host ""
        Write-Host "4. Check VPC endpoints and security groups for CloudWatch access"
    }

} catch {
    Write-Error "Manual solution failed: $($_.Exception.Message)"
    Write-Host ""
    Write-Host "FALLBACK OPTIONS:"
    Write-Host "1. Check VPC endpoints for CloudWatch"
    Write-Host "2. Verify security groups allow HTTPS outbound"
    Write-Host "3. Check if IMDS v2 is properly configured"
    Write-Host "4. Contact AWS support for account-specific issues"
    exit 1
}



# step 7 
################################################################################################################
#
#  .\fixit.ps1 -Region "us-east-2" -InstanceId "i-0aa8b60d4dfbc4c2a"

# Fix IMDSv2 Issue - Enable IMDSv1 or Handle IMDSv2 Properly
# This script provides solutions for the 401 Unauthorized IMDS errors

param(
    [Parameter(Mandatory=$true)]
    [string]$InstanceId,
    
    [Parameter(Mandatory=$true)]
    [string]$Region
)

Write-Host "=== Fix IMDSv2 Issue ===" -ForegroundColor Yellow
Write-Host ""
Write-Host "ISSUE CONFIRMED: IMDS is enabled but requires IMDSv2 tokens" -ForegroundColor Red
Write-Host "Your instance is receiving 401 Unauthorized errors because:" -ForegroundColor Red
Write-Host "- IMDS is enabled (good!)" -ForegroundColor Yellow
Write-Host "- But http-tokens is set to 'required' (IMDSv2 only)" -ForegroundColor Yellow
Write-Host "- The script is using IMDSv1-style requests" -ForegroundColor Yellow
Write-Host ""

# Test if we can get a token (IMDSv2 method)
function Test-IMDSv2 {
    try {
        # Get IMDSv2 token
        $headers = @{ 'X-aws-ec2-metadata-token-ttl-seconds' = '21600' }
        $token = Invoke-RestMethod -Uri "http://169.254.169.254/latest/api/token" -Method PUT -Headers $headers -TimeoutSec 10
        
        if ($token) {
            # Use token to get instance ID
            $tokenHeaders = @{ 'X-aws-ec2-metadata-token' = $token }
            $instanceId = Invoke-RestMethod -Uri "http://169.254.169.254/latest/meta-data/instance-id" -Headers $tokenHeaders -TimeoutSec 10
            Write-Host "SUCCESS: IMDSv2 is working! Retrieved instance ID: $instanceId" -ForegroundColor Green
            return $true
        }
    } catch {
        Write-Host "IMDSv2 test failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    return $false
}

Write-Host "Testing if IMDSv2 is accessible..." -ForegroundColor Yellow
$imdsv2Works = Test-IMDSv2

if ($imdsv2Works) {
    Write-Host ""
    Write-Host "IMDSv2 IS WORKING - Creating IMDSv2-compatible script..." -ForegroundColor Green
    
    # Create IMDSv2-compatible disk metrics script
    $imdsv2Script = @"
# IMDSv2-Compatible Disk Metrics Script
# Generated: $(Get-Date)
param(
    [string]`$InstanceId = "$InstanceId",
    [string]`$Region = "$Region",
    [string]`$LogPath = "C:\Scripts\CloudWatch-DiskMetrics-IMDSv2.log"
)

function Write-MetricLog {
    param([string]`$Message, [string]`$Level = "INFO")
    `$timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    `$logEntry = "[`$timestamp] [`$Level] `$Message"
    Write-Host `$logEntry
    try {
        Add-Content -Path `$LogPath -Value `$logEntry -ErrorAction SilentlyContinue
    } catch { }
}

function Get-IMDSv2Token {
    try {
        `$headers = @{ 'X-aws-ec2-metadata-token-ttl-seconds' = '21600' }
        `$token = Invoke-RestMethod -Uri "http://169.254.169.254/latest/api/token" -Method PUT -Headers `$headers -TimeoutSec 10
        return `$token
    } catch {
        Write-MetricLog "Failed to get IMDSv2 token: `$(`$_.Exception.Message)" "ERROR"
        return `$null
    }
}

function Get-AWSCredentials {
    try {
        `$token = Get-IMDSv2Token
        if (-not `$token) { return `$null }
        
        `$tokenHeaders = @{ 'X-aws-ec2-metadata-token' = `$token }
        
        # Get role name
        `$roleName = Invoke-RestMethod -Uri "http://169.254.169.254/latest/meta-data/iam/security-credentials/" -Headers `$tokenHeaders -TimeoutSec 10
        if (`$roleName -is [Array]) { `$roleName = `$roleName[0] }
        
        # Get credentials
        `$credentials = Invoke-RestMethod -Uri "http://169.254.169.254/latest/meta-data/iam/security-credentials/`$roleName" -Headers `$tokenHeaders -TimeoutSec 10
        return `$credentials
    } catch {
        Write-MetricLog "Failed to get AWS credentials: `$(`$_.Exception.Message)" "ERROR"
        return `$null
    }
}

try {
    # Get credentials using IMDSv2
    `$creds = Get-AWSCredentials
    if (-not `$creds) {
        Write-MetricLog "Cannot get AWS credentials" "ERROR"
        exit 1
    }
    
    # Set AWS credentials as environment variables
    `$env:AWS_ACCESS_KEY_ID = `$creds.AccessKeyId
    `$env:AWS_SECRET_ACCESS_KEY = `$creds.SecretAccessKey
    `$env:AWS_SESSION_TOKEN = `$creds.Token
    `$env:AWS_DEFAULT_REGION = `$Region
    
    # Get disk usage
    `$disk = Get-WmiObject -Class Win32_LogicalDisk -Filter "DeviceID='C:'" -ErrorAction Stop
    if (-not `$disk) {
        Write-MetricLog "Cannot get disk information" "ERROR"
        exit 1
    }
    
    `$totalSize = `$disk.Size
    `$freeSpace = `$disk.FreeSpace
    `$usedSpace = `$totalSize - `$freeSpace
    `$usedPercent = [math]::Round((`$usedSpace / `$totalSize) * 100, 2)
    
    Write-MetricLog "Disk usage: `$usedPercent% (`$([math]::Round(`$usedSpace/1GB, 2)) GB used)"
    
    # Send metric with retry
    `$maxRetries = 3
    `$success = `$false
    
    for (`$i = 1; `$i -le `$maxRetries; `$i++) {
        `$metricData = "MetricName=disk_used_percent,Value=`$usedPercent,Unit=Percent,Dimensions=[{Name=InstanceId,Value=`$InstanceId}]"
        `$result = & aws cloudwatch put-metric-data --region `$Region --namespace "CWAgent" --metric-data `$metricData 2>&1
        
        if (`$LASTEXITCODE -eq 0) {
            Write-MetricLog "SUCCESS: Metric sent (attempt `$i): `$usedPercent%" "SUCCESS"
            `$success = `$true
            break
        } else {
            Write-MetricLog "Attempt `$i failed: `$result" "WARN"
            if (`$i -lt `$maxRetries) { Start-Sleep -Seconds ([math]::Pow(2, `$i)) }
        }
    }
    
    if (-not `$success) {
        Write-MetricLog "Failed to send metric after `$maxRetries attempts" "ERROR"
        exit 1
    }
    
} catch {
    Write-MetricLog "Script failed: `$(`$_.Exception.Message)" "ERROR"
    exit 1
} finally {
    # Clear credentials from environment
    Remove-Item Env:AWS_ACCESS_KEY_ID -ErrorAction SilentlyContinue
    Remove-Item Env:AWS_SECRET_ACCESS_KEY -ErrorAction SilentlyContinue
    Remove-Item Env:AWS_SESSION_TOKEN -ErrorAction SilentlyContinue
}
"@

    # Create the script
    if (!(Test-Path "C:\Scripts")) {
        New-Item -ItemType Directory -Path "C:\Scripts" -Force | Out-Null
    }
    
    $scriptPath = "C:\Scripts\disk-metrics-imdsv2.ps1"
    $imdsv2Script | Out-File $scriptPath -Encoding UTF8
    Write-Host "Created IMDSv2-compatible script: $scriptPath" -ForegroundColor Green
    
    # Test the script
    Write-Host ""
    Write-Host "Testing IMDSv2-compatible script..." -ForegroundColor Yellow
    try {
        $testResult = & PowerShell.exe -ExecutionPolicy Bypass -File $scriptPath
        Write-Host "Script test completed. Check output above for results." -ForegroundColor Green
        
        # Create scheduled task
        Write-Host ""
        Write-Host "Creating scheduled task..." -ForegroundColor Yellow
        $taskName = "CloudWatch-Disk-Metrics-IMDSv2"
        
        # Remove old tasks
        Get-ScheduledTask -TaskName "*CloudWatch-Disk-Metrics*" -ErrorAction SilentlyContinue | ForEach-Object {
            Unregister-ScheduledTask -TaskName $_.TaskName -Confirm:$false -ErrorAction SilentlyContinue
            Write-Host "Removed old task: $($_.TaskName)" -ForegroundColor Yellow
        }
        
        $taskCmd = "PowerShell.exe -WindowStyle Hidden -ExecutionPolicy Bypass -File `"$scriptPath`""
        $result = & schtasks /create /tn $taskName /tr $taskCmd /sc minute /mo 5 /ru SYSTEM /f 2>&1
        
        if ($LASTEXITCODE -eq 0) {
            Write-Host "SUCCESS: Created scheduled task: $taskName" -ForegroundColor Green
            
            # Start task
            & schtasks /run /tn $taskName 2>&1 | Out-Null
            Write-Host "Started task for immediate test" -ForegroundColor Green
            
            Write-Host ""
            Write-Host "=== IMDSv2 SOLUTION COMPLETE ===" -ForegroundColor Green
            Write-Host ""
            Write-Host "WHAT'S WORKING NOW:" -ForegroundColor Green
            Write-Host "- IMDSv2-compatible disk metrics collection" -ForegroundColor White
            Write-Host "- Scheduled task running every 5 minutes" -ForegroundColor White
            Write-Host "- Proper credential handling with token cleanup" -ForegroundColor White
            Write-Host "- Enhanced logging and error handling" -ForegroundColor White
            Write-Host ""
            Write-Host "YOUR ALARM STATUS:" -ForegroundColor Green
            Write-Host "- DiskUtilization-$InstanceId-AutoDiscovered should receive data within 15 minutes" -ForegroundColor White
            Write-Host "- Metrics will include proper InstanceId dimension" -ForegroundColor White
            Write-Host ""
            Write-Host "MONITORING:" -ForegroundColor Green
            Write-Host "- Script: $scriptPath" -ForegroundColor White
            Write-Host "- Logs: C:\Scripts\CloudWatch-DiskMetrics-IMDSv2.log" -ForegroundColor White
            Write-Host "- Task: Task Scheduler > $taskName" -ForegroundColor White
            
        } else {
            Write-Host "Task creation failed but script works manually: $result" -ForegroundColor Yellow
        }
        
    } catch {
        Write-Host "Script test failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
} else {
    Write-Host ""
    Write-Host "IMDSv2 is not accessible either. You have two options:" -ForegroundColor Yellow
    Write-Host ""
    Write-Host "OPTION 1 (RECOMMENDED): Enable IMDSv1 alongside IMDSv2" -ForegroundColor Green
    Write-Host "This allows both IMDSv1 and IMDSv2 requests to work:" -ForegroundColor White
    Write-Host ""
    Write-Host "AWS CLI command (run from admin workstation):" -ForegroundColor Cyan
    Write-Host "aws ec2 modify-instance-metadata-options \\" -ForegroundColor White
    Write-Host "  --instance-id $InstanceId \\" -ForegroundColor White
    Write-Host "  --region $Region \\" -ForegroundColor White
    Write-Host "  --http-endpoint enabled \\" -ForegroundColor White
    Write-Host "  --http-protocol-ipv4 enabled \\" -ForegroundColor White
    Write-Host "  --http-tokens optional" -ForegroundColor White
    Write-Host ""
    Write-Host "AWS Console method:" -ForegroundColor Cyan
    Write-Host "1. Go to EC2 Console > Instances" -ForegroundColor White
    Write-Host "2. Select instance $InstanceId" -ForegroundColor White
    Write-Host "3. Actions > Instance Settings > Modify instance metadata options" -ForegroundColor White
    Write-Host "4. Change 'Require IMDSv2' from 'Required' to 'Optional'" -ForegroundColor White
    Write-Host ""
    Write-Host "OPTION 2: Use AWS CLI with explicit credentials" -ForegroundColor Yellow
    Write-Host "Configure AWS CLI with access keys as a temporary workaround" -ForegroundColor White
    Write-Host ""
    Write-Host "After enabling IMDSv1 (Option 1), re-run the enhanced script:" -ForegroundColor Green
    Write-Host ".\enhanced-cloudwatch-disk-monitoring.ps1 -Region $Region -InstanceId $InstanceId" -ForegroundColor White
}

Write-Host ""
Write-Host "SUMMARY:" -ForegroundColor Cyan
Write-Host "- The enhanced script correctly identified the IMDS issue" -ForegroundColor White
Write-Host "- IMDS is enabled but configured for IMDSv2-only access" -ForegroundColor White
Write-Host "- Solution provided above will resolve the monitoring issue" -ForegroundColor White
Write-Host "- Your alarm will work consistently once IMDS access is fixed" -ForegroundColor White

